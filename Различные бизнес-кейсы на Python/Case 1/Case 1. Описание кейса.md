# Кейс 1. Объединение чеков

## Описание

Нам порой прилетают задачки от наших клиентов, и они не всегда предполагают непосредственную аналитику. Мы, наверное, вас и не удивим, если скажем, что даже в аналитических задачах большую часть работы у вас займет сбор данных и их предобработка. Вот и нам иногда приходится подумать над тем, как лучше нужные данные найти и собрать, а это то, что всегда хочется это автоматизировать. Мы ведь тут не просто ручной работой занимаемся, а стараемся упростить повседневные задачи.

Так вот, есть у нас один клиент, он управляет магазинами. Каждый из его магазинов периодически отправляет свои записи о продажах ("чеки") в виде `CSV`\-файлов, где каждый файл - это продажи в определенный день. Однако не всегда все так гладко, и порой они забывают удалить ненужную или лишнюю информацию из файлов, которые они отправляют. Что еще хуже, они также отправляют лишние файлы с другими расширениями и именами, которые не имеют ничего общего с записями о продажах.

Что нам нужно? Объединить записи о продажах (чеки) из каждого магазина в единый **унифицированный** набор данных.

Глобально, это и есть ваша задача - написать **скрипт**, который сможет автоматически обрабатывать эти файлы, отфильтровывая все, что не нужно, и объединять содержимое оставшихся файлов в единый набор.

**По какому принципу отбирать файлы?**

Имя каждого файла, отправляемого магазинами, соответствует определенному шаблону: `ГГГГ-ММ-ДД-ЧЧ-ММ-idклиента.csv`, где `ГГГГ` - это год, `ММ` - месяц, `ДД` - день, `ЧЧ` - час, `ММ` - минута, а `id клиента` - это уникальный идентификатор. Ваш скрипт должен обрабатывать только те файлы, которые соответствуют этому шаблону.

**Результат**

Окончательный набор данных (уже объединенный) должен называться `combined_data.csv` и содержать все "чеки" из исходных файлов, причем строкой заголовка будет первая строка первого обработанного файла. В итоге скрипт должен сохранить объединенный файл в некоторую папку, чтобы клиент мог просмотреть и проанализировать его.

**Важно:** напишите функцию и назовите её `process_files`. Сделайте так, чтобы она принимала на вход первый путь - откуда брать файлы, и второй путь - куда сохранять. Так, ваш код будет максимально универсальным и применимым для любых папок.

## Подсказки

Чтобы найти подходящие по названию и типу файлы есть два пути. Первый - простой, даже примитивный, но его вы можете реализовать уже сейчас, с имеющимися у вас знаниями.

По сути, что нужно сделать: посчитать количество символов в названии файла - если подходит под шаблон, значит это наш первый претендент на подходящий "чек". Далее, для детальной проверки можем "по кусочкам" посмотреть: первые четыре символа - числа? Следующий знак - тире? Идут ли затем еще два числа? И так далее.

Второй подход сложнее - придется немного нырнуть в тему регулярных выражений. Потому что кроме такой простой ручной проверки и регулярок, других инструментов для поиска определенного шаблона символов - нет.

**Объясняем регулярные выражения**

Во-первых, вам придется импортировать дополнительный модуль - `import re`.

А потом, использовать функцию `re.match`. Её работа в том, чтобы сопоставить строку определенному шаблону.

В эту функцию нужно будет передать 2 аргумента: шаблон `r'\d{4}-\d{2}-\d{2}-\d{2}-\d{2}-\d+.csv'` и строки, в которых этот шаблон надо будет искать.

Разберем по частям.

- `r`, в начале строки шаблона указывает на то, что это необработанная строка, то есть обратные косые черты внутри строки следует рассматривать как буквальные обратные косые черты, а не как escape-символы.
- Далее идет сам шаблон. Он начинается с `\d{4}`, что значит найди четыре идущие подряд цифры (любые цифры от нуля до девяти).
- Затем в шаблоне должен идти дефис `-` указываем его.
- Потом `\d{2}`, который соответствует уже двум цифрам, потом еще один дефис и так далее, в общей сложности _шесть групп цифр и дефисов_.
- В конце у нас есть `-\d+.csv`: `-` и `.csv` - это символы, которые должны присутствовать в имени файла, а `\d+` соответствует одной или нескольким цифрам.

Таким образом, такой шаблон соответствует именам файлов, которые состоят из строки цифр и дефисов в формате `ГГГГ-ММ-ДД-ЧЧ-ММ`, за которыми следует одна или несколько цифр и расширение `.csv`.

Например, имя файла `2022-01-15-10-30-1.csv` будет отобрано как подходящее, но имя файла `2022-01-15-10:30:1.csv` (с двоеточиями вместо дефисов) - не будет.

Теперь, наверняка, у вас есть другой вопрос, а как просмотреть содержимое папки не вручную, а автоматически? Как собственно передать строки в тот же `re.match()`? Все очень просто, вы уже немного касались библиотеки **glob**, тут-то она и пригодится.
